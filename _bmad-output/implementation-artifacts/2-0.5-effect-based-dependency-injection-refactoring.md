# Story 2-0.5: Effect-Based Dependency Injection Refactoring

**Story ID:** 2.0.5  
**Status:** ready-for-dev  
**Created:** 2026-01-31

---

## Story

As a **Backend Developer**,
I want **to centralize database and Better Auth dependency injection using Effect-ts patterns**,
So that **handlers are testable, all dependencies are mockable, and we have a clean foundation for Stories 2.1+**.

---

## Acceptance Criteria

### 1. Database Injection (DatabaseRef)

**Current:** Direct imports of database instance  
**Target:** All database access via `yield* DatabaseRef.get()`

- [ ] Verify DatabaseRef exists and properly initialized
- [ ] All handlers use `yield* DatabaseRef.get()` (not direct imports)
- [ ] Drizzle adapter receives database through DI (not hardcoded)
- [ ] Tests can inject mock database via Layer

### 2. Better Auth Factory (Effect-Based)

**Current:** Better Auth created imperatively in server setup  
**Target:** BetterAuthRef FiberRef with Effect factory

- [ ] Create BetterAuthRef FiberRef bridge
- [ ] Create BetterAuthFactory that receives db via DI
- [ ] Factory returns initialized auth instance via Effect.sync
- [ ] Tests can inject mock Better Auth via Layer
- [ ] Maintain hybrid HTTP request handling (no changes to middleware)

### 3. Centralized Layer Composition

**Current:** Services scattered across index.ts  
**Target:** All services in single Layer.mergeAll()

- [ ] DatabaseLive layer properly defined
- [ ] LoggerServiceLive layer properly defined
- [ ] BetterAuthLive layer properly defined
- [ ] All services merged in server setup
- [ ] Clear dependency flow: Layers → Handlers via FiberRef

### 4. Effect Services Pattern (NEW REQUIREMENT)

**Current:** Using FiberRef for service injection
**Target:** Use official Effect `Context.Tag` pattern for proper service DI

- [ ] Database service uses `Context.Tag` instead of FiberRef
- [ ] Service interfaces have no requirements (clean separation)
- [ ] Layers manage dependencies during construction (not at service level)
- [ ] Service shape extractable via `Context.Tag.Service<ServiceTag>`
- [ ] Follow official Effect pattern from https://effect.website/docs/requirements-management/services/

### 5. Database Layer Pattern (NEW REQUIREMENT)

**Reference:** https://effect.website/docs/requirements-management/layers/#database

- [ ] DatabaseLive uses `Layer.effect` with dependency injection
- [ ] Database service returns `Effect.Effect<unknown>` with no requirements
- [ ] Dependencies (config, logger) resolved during layer construction
- [ ] Layer type clearly expresses requirements: `Layer<Database, never, Config | ...>`

### 6. No Breaking Changes

- [ ] All existing tests pass (no regressions)
- [ ] API contracts unchanged
- [ ] HTTP hybrid request handling unchanged
- [ ] Existing handlers continue to work

---

## Key Technical Requirement: DI for Drizzle Adapter

**CRITICAL:** The Drizzle adapter MUST receive the database through dependency injection.

### Current Pattern (ANTI-PATTERN)

```typescript
// packages/infrastructure/src/refs/database.ts (BAD)

import { db } from "./database.js" // DIRECT IMPORT - ANTI-PATTERN

const adapter = drizzleAdapter(db) // HARDCODED - can't mock for tests

export const BetterAuthLive = Layer.effect(
  BetterAuthRef,
  Effect.sync(() => lucia({ adapter, ... }))
)
```

**Problem:** When testing, we can't inject a mock database because the adapter is hardcoded at module load time.

### Target Pattern (CORRECT - Effect Services)

```typescript
// packages/infrastructure/src/context/database.ts (OFFICIAL DRIZZLE + EFFECT PATTERN)

import { Context, Layer, Effect, Redacted } from "effect"
import { drizzle } from "drizzle-orm/effect-postgres"
import { PgClient } from "@effect/sql-pg"
import { types } from "pg"
import * as authSchema from "../auth-schema.js"

/**
 * PostgreSQL Client Layer (Connection Pool)
 */
export const PgClientLive = PgClient.layer({
  url: Redacted.make(
    process.env.DATABASE_URL ||
    "postgresql://dev:devpassword@localhost:5432/bigocean"
  ),
  types: {
    getTypeParser: (typeId, format) => {
      // Preserve date/time types as strings
      if ([1184, 1114, 1082, 1186, 1231, 1115, 1185, 1187, 1182].includes(typeId)) {
        return (val: any) => val
      }
      return types.getTypeParser(typeId, format)
    }
  }
})

/**
 * Database Service Tag
 *
 * Using Context.Tag for proper Effect dependency injection.
 * Service interface has NO requirements - dependencies managed during layer construction.
 */
export class Database extends Context.Tag("Database")<
  Database,
  ReturnType<typeof drizzle>
>() {}

/**
 * Database Layer - Dependencies resolved during construction
 *
 * Layer type: Layer<Database, never, PgClient>
 * Notice: Service has no requirements, only layer has dependencies
 */
export const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    // Dependency: PgClient resolved during layer construction
    const client = yield* PgClient.PgClient

    // Create Drizzle instance with Effect Postgres driver
    const db = drizzle(client, {
      schema: authSchema,
      logger: process.env.NODE_ENV === "development"
    })

    return db
  })
)

/**
 * Complete Database Stack
 */
export const DatabaseStack = DatabaseLive.pipe(
  Layer.provide(PgClientLive)
)

// Usage in handlers:
const program = Effect.gen(function* () {
  const database = yield* Database
  const users = yield* database.query.users.findMany()
  return users
})
```

```typescript
// packages/infrastructure/src/context/better-auth.ts (OFFICIAL PATTERN)

import { Context, Layer, Effect } from "effect"
import { Database } from "./database.js"
import { drizzleAdapter } from "better-auth/adapters/drizzle"
import { betterAuth } from "better-auth"

/**
 * Better Auth Service Tag
 *
 * Service interface has NO requirements - dependencies managed by layer
 */
export class BetterAuthService extends Context.Tag("BetterAuthService")<
  BetterAuthService,
  {
    readonly validateSession: (sessionId: string) => Effect.Effect<unknown>
    readonly handler: (req: Request) => Promise<Response>
  }
>() {}

/**
 * Better Auth Layer - Receives database through DI
 *
 * Layer type: Layer<BetterAuthService, never, Database>
 * Database dependency resolved during construction, not at service level
 */
export const BetterAuthLive = Layer.effect(
  BetterAuthService,
  Effect.gen(function* () {
    // KEY: Receive database through DI during layer construction
    const database = yield* Database

    // Create adapter with injected database
    const adapter = drizzleAdapter(database.instance, {
      provider: "pg",
      schema: authSchema
    })

    // Initialize Better Auth with adapter
    const auth = betterAuth({
      database: adapter,
      baseURL: process.env.BETTER_AUTH_URL || "http://localhost:4000",
      secret: process.env.BETTER_AUTH_SECRET || "dev-secret",
      emailAndPassword: {
        enabled: true,
        minPasswordLength: 12
      }
    })

    return {
      validateSession: (sessionId: string) =>
        Effect.tryPromise(() => auth.api.getSession({ headers: new Headers() })),
      handler: auth.handler
    }
  })
)

// Usage in handlers:
const program = Effect.gen(function* () {
  const betterAuth = yield* BetterAuthService
  const session = yield* betterAuth.validateSession("session-id")
  return session
})
```

### Testing With Injected Mock Database

```typescript
// apps/api/src/__tests__/auth-integration.test.ts

import { Effect, Layer } from "effect"
import { mockDatabase, createTestSession } from "@workspace/domain/test-utils"
import { createBetterAuthInstance } from "@workspace/infrastructure"
import { DatabaseRef } from "@workspace/infrastructure"

describe("Better Auth with Injected Database", () => {
  it("should initialize with mock database", async () => {
    const mockDb = mockDatabase() // In-memory test database

    // Create auth with injected mock database
    const authEffect = createBetterAuthInstance().pipe(
      Layer.provide(Layer.succeed(DatabaseRef, mockDb))
    )

    const auth = await Effect.runPromise(authEffect)

    expect(auth).toBeDefined()
    // Auth now uses the mock database, not production database
  })

  it("should use injected database for session lookup", async () => {
    const mockDb = mockDatabase()
    const testSession = createTestSession()

    await Effect.runPromise(
      mockDb.sessions.insert(testSession).pipe(
        Layer.provide(Layer.succeed(DatabaseRef, mockDb))
      )
    )

    const authEffect = createBetterAuthInstance().pipe(
      Layer.provide(Layer.succeed(DatabaseRef, mockDb))
    )

    const auth = await Effect.runPromise(authEffect)
    
    // Verify auth adapter is using the mock database
    // (This would depend on Lucia's API for session lookup)
    const session = await auth.validateSession(testSession.id)
    expect(session).toBeDefined()
  })
})
```

---

## Implementation Plan

### Phase 1: Create Database Service with Effect + Drizzle (Day 1)

**Action:** Create `packages/infrastructure/src/context/database.ts` using official Drizzle Effect Postgres pattern

**References:**
- Effect Services: https://effect.website/docs/requirements-management/services/
- Effect Layers: https://effect.website/docs/requirements-management/layers/#database
- Drizzle Effect Postgres: https://orm.drizzle.team/docs/connect-effect-postgres

**Requirements:**
- Use `@effect/sql-pg` with `drizzle-orm/effect-postgres` (official integration)
- Use `Context.Tag` for service definition (NOT FiberRef)
- Service interface must have NO requirements
- Dependencies resolved during layer construction
- PgClient layer for connection management

```typescript
// packages/infrastructure/src/context/database.ts

import { Context, Layer, Effect, Redacted } from "effect"
import { drizzle } from "drizzle-orm/effect-postgres"
import { PgClient } from "@effect/sql-pg"
import { types } from "pg"
import * as authSchema from "../auth-schema.js"

/**
 * PostgreSQL Client Layer
 *
 * Manages connection pool with Effect-based lifecycle
 */
export const PgClientLive = PgClient.layer({
  url: Redacted.make(
    process.env.DATABASE_URL ||
    "postgresql://dev:devpassword@localhost:5432/bigocean"
  ),
  types: {
    // Preserve PostgreSQL date/time types as strings (not parsed to Date)
    getTypeParser: (typeId, format) => {
      if ([1184, 1114, 1082, 1186, 1231, 1115, 1185, 1187, 1182].includes(typeId)) {
        return (val: any) => val
      }
      return types.getTypeParser(typeId, format)
    }
  }
})

/**
 * Database Service Tag
 *
 * CRITICAL: Service interface has NO requirements parameter
 * Dependencies managed during layer construction, not at service level
 */
export class Database extends Context.Tag("Database")<
  Database,
  ReturnType<typeof drizzle>
>() {}

/**
 * Database Layer
 *
 * Layer type: Layer<Database, never, PgClient>
 * Notice: Service returns Effect<unknown> with no requirements
 */
export const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    // Dependency: PgClient resolved during layer construction
    const client = yield* PgClient.PgClient

    // Create Drizzle instance with Effect Postgres driver
    const db = drizzle(client, {
      schema: authSchema,
      logger: process.env.NODE_ENV === "development"
    })

    return db
  })
)

/**
 * Complete Database Stack
 *
 * Merges PgClient and Database layers
 * Usage: Layer.provide(DatabaseStack, program)
 */
export const DatabaseStack = DatabaseLive.pipe(
  Layer.provide(PgClientLive)
)
```

**Key Benefits:**
- Official Drizzle + Effect integration via `@effect/sql-pg`
- "Layers act as constructors for creating services, allowing us to manage dependencies during construction rather than at the service level"
- Clean service interfaces with no requirements
- Connection pooling managed by Effect
- Type-safe dependency management

### Phase 2: Create Better Auth Ref Bridge (Day 1-2)

**Action:** Create `packages/infrastructure/src/refs/better-auth.ts`

Key requirement: **Receive database through DI**

```typescript
// packages/infrastructure/src/refs/better-auth.ts

import { FiberRef, Layer, Effect } from "effect"
import { DatabaseRef } from "./database.js"
import { drizzleAdapter } from "better-auth/adapters/drizzle"
import { lucia } from "better-auth/lucia"

export const BetterAuthRef = FiberRef.unsafeMake<LuciaAuth | null>(null)

export const createBetterAuthInstance = (): Effect.Effect<
  LuciaAuth,
  never,
  never
> =>
  Effect.gen(function* () {
    // KEY: Receive database through DI
    const db = yield* DatabaseRef.get()

    const adapter = drizzleAdapter(db) // Now uses injected db

    return lucia({
      adapter,
      env: process.env.NODE_ENV === "production" ? "PROD" : "DEV",
      sessionCookie: {
        name: "session",
        attributes: {
          secure: process.env.NODE_ENV === "production",
          httpOnly: true,
          sameSite: "lax",
        },
      },
    })
  })

export const BetterAuthLive = Layer.effect(
  BetterAuthRef,
  createBetterAuthInstance()
)

export const getBetterAuth = Effect.gen(function* () {
  const auth = yield* FiberRef.get(BetterAuthRef)
  if (!auth) {
    return yield* Effect.fail(new Error("BetterAuth not initialized"))
  }
  return auth
})
```

### Phase 3: Update Server Setup (Day 2)

**Action:** Update `apps/api/src/index.ts` with layer composition

```typescript
// apps/api/src/index.ts

import { Layer, Effect } from "effect"
import { NodeRuntime } from "@effect/platform-node"
import {
  DatabaseLive,
  LoggerServiceLive,
  BetterAuthLive,
} from "@workspace/infrastructure"

// All services in single composition
const ServiceLayers = Layer.mergeAll(
  DatabaseLive,
  LoggerServiceLive,
  BetterAuthLive,
  // Add more as needed
)

const ApiLive = HttpApiBuilder.api(BigOceanApi).pipe(
  Layer.provide(
    Layer.mergeAll(
      HttpGroupsLive,  // Assessment handlers
      ServiceLayers,   // All backend services
    )
  ),
  // ... rest of server setup
)

NodeRuntime.runMain(Layer.launch(ApiLive))
```

### Phase 4: Verify Handlers (Day 2-3)

**Action:** Verify all handlers use injected dependencies

```typescript
// Example: Handler using injected database and auth

export const AssessmentHandler = HttpApiBuilder.handler(
  BigOceanApi.startAssessment,
  ({ payload }) =>
    Effect.gen(function* () {
      // Injected database
      const db = yield* DatabaseRef.get()

      // Injected auth
      const auth = yield* getBetterAuth()

      // Use both
      const session = yield* db.sessions.create({...})
      const authSession = yield* auth.validateSession(...)

      return { sessionId: session.id }
    })
)
```

### Phase 5: Testing (Day 3-4)

**Action:** Write tests to verify DI works correctly

```typescript
// Test with mock database

const testEffect = handler.pipe(
  Layer.provide(Layer.succeed(DatabaseRef, mockDb)),
  Layer.provide(Layer.succeed(BetterAuthRef, mockAuth))
)

const result = await Effect.runPromise(testEffect)
```

### Phase 6: Documentation (Day 4)

- [ ] Update CLAUDE.md with DI pattern
- [ ] Add JSDoc to all Refs and Layers
- [ ] Document how to add new services
- [ ] Update example in README

---

## Files to Create/Modify

**Dependencies to Install:**
```bash
pnpm add @effect/sql-pg
pnpm add drizzle-orm@latest  # Ensure latest version with effect-postgres support
```

**Create:**
- `packages/infrastructure/src/context/database.ts` (NEW - Effect + Drizzle pattern)
- `packages/infrastructure/src/context/better-auth.ts` (NEW - Effect Services pattern)
- `packages/infrastructure/src/__tests__/database.test.ts` (NEW - Layer testing)
- `packages/infrastructure/src/__tests__/better-auth.test.ts` (NEW - Layer testing)

**Modify:**
- `packages/infrastructure/src/index.ts` (export new services)
- `apps/api/src/index.ts` (update layer composition)
- `apps/api/src/setup.ts` (REMOVE - no longer needed with Effect layers)
- `apps/api/src/auth.ts` (REFACTOR - use Effect service instead of imperative init)
- `apps/api/src/middleware/better-auth.ts` (UPDATE - access service via Effect)

**Remove:**
- `packages/infrastructure/src/database.ts` (OLD - replaced by context/database.ts)
- Direct `db` imports in any handlers

---

## Success Metrics

✅ Database service uses official Drizzle Effect Postgres (`@effect/sql-pg`)
✅ All services use `Context.Tag` (not FiberRef)
✅ Service interfaces have NO requirements (clean separation)
✅ Layers manage dependencies during construction
✅ Database and Better Auth fully injectable via Effect Layers
✅ Tests can inject mock services via Layer.succeed
✅ No hardcoded imports in factories
✅ All existing tests pass (no regressions)
✅ Hybrid HTTP request handling unchanged
✅ Clear foundation for Stories 2.1-2.5

**Official Patterns Followed:**
- ✅ Effect Services: https://effect.website/docs/requirements-management/services/
- ✅ Effect Layers: https://effect.website/docs/requirements-management/layers/#database
- ✅ Drizzle Effect Postgres: https://orm.drizzle.team/docs/connect-effect-postgres  

---

## Dev Notes: Critical Architectural Patterns

### Effect Services Pattern (MUST FOLLOW)

**Core Principle:** "Layers act as constructors for creating services, allowing us to manage dependencies during construction rather than at the service level."

**Service Definition Pattern:**
```typescript
// CORRECT: Service interface has NO requirements
export class ServiceName extends Context.Tag("ServiceName")<
  ServiceName,
  { readonly method: () => Effect.Effect<Result> }  // NO Requirements parameter!
>() {}
```

**Why This Matters:**
- Service interfaces stay clean and focused
- Dependencies managed at construction time (layers), not usage time
- Enables straightforward testing through layer substitution
- Type system ensures all dependencies provided

### Layer Construction Pattern (MUST FOLLOW)

**Pattern:**
```typescript
export const ServiceLive = Layer.effect(
  ServiceTag,
  Effect.gen(function* () {
    // Dependencies resolved HERE during construction
    const dependency1 = yield* Dependency1
    const dependency2 = yield* Dependency2

    // Return service implementation
    return {
      method: () => Effect.sync(() => {
        // Use dependencies captured during construction
        return result
      })
    }
  })
)
```

**Layer Type Signature:**
- `Layer<ServiceTag, never, Dependency1 | Dependency2>`
- Clearly shows what dependencies are required to construct the service

### Drizzle Effect Postgres (OFFICIAL INTEGRATION)

**Installation:**
```bash
pnpm add @effect/sql-pg drizzle-orm@latest
```

**Connection Layer:**
```typescript
import { PgClient } from "@effect/sql-pg"
import { Redacted } from "effect"

export const PgClientLive = PgClient.layer({
  url: Redacted.make(process.env.DATABASE_URL!),
  types: {
    getTypeParser: (typeId, format) => {
      // Preserve PostgreSQL date/time types as strings
      if ([1184, 1114, 1082, 1186, 1231, 1115, 1185, 1187, 1182].includes(typeId)) {
        return (val: any) => val
      }
      return types.getTypeParser(typeId, format)
    }
  }
})
```

**Database Layer:**
```typescript
import { drizzle } from "drizzle-orm/effect-postgres"

export const DatabaseLive = Layer.effect(
  Database,
  Effect.gen(function* () {
    const client = yield* PgClient.PgClient
    return drizzle(client, { schema: authSchema })
  })
)
```

### Testing with Layers

**Mock Service Pattern:**
```typescript
const MockDatabaseLive = Layer.succeed(Database, {
  // Mock implementation
  query: { users: { findMany: Effect.succeed([]) } }
})

const program = Effect.gen(function* () {
  const db = yield* Database
  return yield* db.query.users.findMany()
})

// Test with mock
await Effect.runPromise(
  program.pipe(Effect.provide(MockDatabaseLive))
)
```

### Service Access in Handlers

**Pattern:**
```typescript
const handler = Effect.gen(function* () {
  // Access service by yielding the tag
  const database = yield* Database
  const betterAuth = yield* BetterAuthService

  // Use services (they have no requirements!)
  const users = yield* database.query.users.findMany()
  const session = yield* betterAuth.validateSession(sessionId)

  return { users, session }
})
```

### Layer Composition

**Merge Multiple Layers:**
```typescript
const ServiceLayers = Layer.mergeAll(
  DatabaseStack,      // Database + PgClient
  BetterAuthLive,     // BetterAuth (depends on Database)
  LoggerServiceLive   // Logger (independent)
)

// Provide to API
const ApiLive = HttpApiBuilder.api(BigOceanApi).pipe(
  Layer.provide(ServiceLayers)
)
```

### Migration from Current Pattern

**Before (ANTI-PATTERN):**
```typescript
// setup.ts - module-level init
const { db } = createDatabaseConnection(process.env.DATABASE_URL!)
export { db }

// auth.ts - hardcoded import
import { db } from "./setup.js"
export const auth = betterAuth({ database: drizzleAdapter(db) })
```

**After (CORRECT):**
```typescript
// context/database.ts - Effect service
export class Database extends Context.Tag("Database")<...>() {}
export const DatabaseLive = Layer.effect(Database, ...)

// context/better-auth.ts - Dependency injection
export const BetterAuthLive = Layer.effect(
  BetterAuthService,
  Effect.gen(function* () {
    const database = yield* Database  // Injected!
    return betterAuth({ database: drizzleAdapter(database.instance) })
  })
)
```

---

**Ready for Development** ✅
