import type { BaseMessage } from "@langchain/core/messages";
import { Context, Effect } from "effect";
import type {
	FacetEvidence,
	FacetName,
	FacetScoresMap,
	TraitScoresMap,
} from "../types/facet-evidence";
import type { TokenUsage } from "./nerin-agent.repository";

/**
 * Re-export TokenUsage for convenience
 */
export type { TokenUsage };

/**
 * Input for orchestrator message processing
 */
export interface ProcessMessageInput {
	/** Session identifier */
	readonly sessionId: string;

	/** User message content */
	readonly userMessage: string;

	/** Previous message history (optional) */
	readonly messages?: BaseMessage[];

	/** Current message count in session (1-indexed) */
	readonly messageCount: number;

	/** Current daily cost used in dollars */
	readonly dailyCostUsed: number;

	/** Optional existing facet scores (includes confidence 0-100 integers) */
	readonly facetScores?: FacetScoresMap;
}

/**
 * Output from orchestrator message processing
 */
export interface ProcessMessageOutput {
	/** Response generated by Nerin agent */
	readonly nerinResponse: string;

	/** Token usage metrics */
	readonly tokenUsage: TokenUsage;

	/** Cost incurred for this message (in dollars) */
	readonly costIncurred: number;

	/** Facet evidence extracted (only on batch processing - every 3rd message) */
	readonly facetEvidence?: FacetEvidence[];

	/** Aggregated facet scores (only on batch processing) */
	readonly facetScores?: FacetScoresMap;

	/** Derived trait scores (only on batch processing) */
	readonly traitScores?: TraitScoresMap;

	/** Single steering target facet (outlier with lowest confidence) */
	readonly steeringTarget?: FacetName;

	/** Natural language steering hint for Nerin */
	readonly steeringHint?: string;
}

/**
 * Orchestrator Repository Service Tag
 *
 * Defines the contract for the multi-agent orchestration system.
 * Coordinates Nerin (conversational), Analyzer (evidence extraction),
 * and Scorer (aggregation) agents via LangGraph state machine.
 *
 * Following hexagonal architecture:
 * - This is the PORT (interface) in domain layer
 * - Implementation (ADAPTER) lives in infrastructure layer
 *
 * Routing Logic:
 * 1. FIRST: Check budget - throw BudgetPausedError if daily limit exceeded
 * 2. Calculate steering target via outlier detection (weakest facet)
 * 3. Always route to Nerin for response generation
 * 4. Every 3rd message triggers Analyzer + Scorer batch
 *
 * @see packages/infrastructure/src/repositories/orchestrator.langgraph.repository.ts
 */
export class OrchestratorRepository extends Context.Tag("OrchestratorRepository")<
	OrchestratorRepository,
	{
		/**
		 * Process a user message through the orchestration pipeline
		 *
		 * @param input - Session context, message, and cost tracking data
		 * @returns Effect with Nerin response and optional scoring data
		 * @throws OrchestrationError - Generic routing/pipeline failure
		 * @throws BudgetPausedError - Daily cost limit reached, assessment paused
		 */
		readonly processMessage: (
			input: ProcessMessageInput,
		) => Effect.Effect<ProcessMessageOutput, OrchestrationError | BudgetPausedError, never>;
	}
>() {}

/**
 * Generic orchestration error (500)
 *
 * Represents a failure in the orchestration pipeline that doesn't
 * fall into a more specific category.
 */
export class OrchestrationError extends Error {
	readonly _tag = "OrchestrationError";

	constructor(
		public readonly sessionId: string,
		public readonly message: string,
		public readonly cause?: string,
	) {
		super(message);
		this.name = "OrchestrationError";
	}
}

/**
 * Budget paused error (503)
 *
 * Thrown when daily cost limit is approached. The assessment is paused
 * gracefully rather than continuing with degraded quality.
 *
 * Session state is preserved exactly - resume tomorrow with same
 * precision, facet scores, and steering context intact.
 */
export class BudgetPausedError extends Error {
	readonly _tag = "BudgetPausedError";

	constructor(
		/** Session identifier for resumption */
		public readonly sessionId: string,

		/** User-friendly explanation */
		public override readonly message: string,

		/** When the session can be resumed (next day midnight UTC) */
		public readonly resumeAfter: Date,

		/** Current confidence (0-100 integer) so user knows their progress */
		public readonly currentConfidence: number,
	) {
		super(message);
		this.name = "BudgetPausedError";
	}
}

/**
 * Confidence gap calculation error (422)
 *
 * Thrown when confidence or steering calculations fail unexpectedly.
 * This is a programming error - the system should always be able to
 * calculate confidence from available data.
 */
export class ConfidenceGapError extends Error {
	readonly _tag = "ConfidenceGapError";

	constructor(
		public readonly sessionId: string,
		public readonly message: string,
		public readonly cause?: string,
	) {
		super(message);
		this.name = "ConfidenceGapError";
	}
}

/**
 * @deprecated Use ConfidenceGapError instead
 */
export const PrecisionGapError = ConfidenceGapError;
