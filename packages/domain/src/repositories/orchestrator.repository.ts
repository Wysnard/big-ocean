import { Context, Effect } from "effect";
import type { FacetName } from "../types/facet-evidence";
import type { DomainMessage } from "../types/message";
import type { TokenUsage } from "./nerin-agent.repository";

/**
 * Re-export TokenUsage for convenience
 */
export type { TokenUsage };

/**
 * Input for orchestrator message processing
 *
 * Story 2.11: facetScores removed — router reads evidence internally on STEER messages.
 */
export interface ProcessMessageInput {
	/** Session identifier */
	readonly sessionId: string;

	/** User message content */
	readonly userMessage: string;

	/** Previous message history (optional) */
	readonly messages?: DomainMessage[];

	/** Current message count in session (1-indexed) */
	readonly messageCount: number;

	/** Current daily cost used in dollars */
	readonly dailyCostUsed: number;
}

/**
 * Output from orchestrator message processing
 *
 * Story 2.11: Lean output — facetEvidence, facetScores, traitScores removed.
 * Batch decision (shouldAnalyze) computed by caller from messageCount.
 */
export interface ProcessMessageOutput {
	/** Response generated by Nerin agent */
	readonly nerinResponse: string;

	/** Token usage metrics */
	readonly tokenUsage: TokenUsage;

	/** Cost incurred for this message (in dollars) */
	readonly costIncurred: number;

	/** Single steering target facet (outlier with lowest confidence) */
	readonly steeringTarget?: FacetName;

	/** Natural language steering hint for Nerin */
	readonly steeringHint?: string;
}

/**
 * Input for background analysis pipeline
 *
 * Story 2.11: Fired as Effect.forkDaemon on batch messages.
 */
export interface ProcessAnalysisInput {
	/** Session identifier */
	readonly sessionId: string;

	/** Full message history for analysis context */
	readonly messages: DomainMessage[];

	/** Current message count (triggers batch at multiples of 3) */
	readonly messageCount: number;
}

/**
 * Orchestrator Repository Service Tag
 *
 * Defines the contract for the multi-agent orchestration system.
 * Coordinates Nerin (conversational), Analyzer (evidence extraction),
 * and Scorer (aggregation) agents via LangGraph state machine.
 *
 * Following hexagonal architecture:
 * - This is the PORT (interface) in domain layer
 * - Implementation (ADAPTER) lives in infrastructure layer
 *
 * Routing Logic:
 * 1. FIRST: Check budget - throw BudgetPausedError if daily limit exceeded
 * 2. Calculate steering target via outlier detection (weakest facet)
 * 3. Always route to Nerin for response generation
 * 4. Every 3rd message triggers Analyzer + Scorer batch
 *
 * @see packages/infrastructure/src/repositories/orchestrator.langgraph.repository.ts
 */
export class OrchestratorRepository extends Context.Tag("OrchestratorRepository")<
	OrchestratorRepository,
	{
		/**
		 * Process a user message through the conversation pipeline (router → nerin → END)
		 *
		 * Story 2.11: Returns lean response. Analyzer no longer inline — use processAnalysis.
		 *
		 * @param input - Session context, message, and cost tracking data
		 * @returns Effect with Nerin response, cost, and steering data
		 * @throws OrchestrationError - Generic routing/pipeline failure
		 * @throws BudgetPausedError - Daily cost limit reached, assessment paused
		 */
		readonly processMessage: (
			input: ProcessMessageInput,
		) => Effect.Effect<ProcessMessageOutput, OrchestrationError | BudgetPausedError, never>;

		/**
		 * Run background analysis pipeline (analyzer → scorer)
		 *
		 * Story 2.11: Called as Effect.forkDaemon on batch messages.
		 * Runs independently of the HTTP response lifecycle.
		 *
		 * @param input - Session context and message history for analysis
		 * @returns Effect<void> — fire-and-forget, errors caught by caller
		 * @throws OrchestrationError - Analysis pipeline failure
		 */
		readonly processAnalysis: (
			input: ProcessAnalysisInput,
		) => Effect.Effect<void, OrchestrationError, never>;
	}
>() {}

/**
 * Generic orchestration error (500)
 *
 * Represents a failure in the orchestration pipeline that doesn't
 * fall into a more specific category.
 */
export class OrchestrationError extends Error {
	readonly _tag = "OrchestrationError";

	constructor(
		public readonly sessionId: string,
		public readonly message: string,
		public readonly cause?: string,
	) {
		super(message);
		this.name = "OrchestrationError";
	}
}

/**
 * Budget paused error (503)
 *
 * Thrown when daily cost limit is approached. The assessment is paused
 * gracefully rather than continuing with degraded quality.
 *
 * Session state is preserved exactly - resume tomorrow with same
 * precision, facet scores, and steering context intact.
 */
export class BudgetPausedError extends Error {
	readonly _tag = "BudgetPausedError";

	constructor(
		/** Session identifier for resumption */
		public readonly sessionId: string,

		/** User-friendly explanation */
		public override readonly message: string,

		/** When the session can be resumed (next day midnight UTC) */
		public readonly resumeAfter: Date,

		/** Current confidence (0-100 integer) so user knows their progress */
		public readonly currentConfidence: number,
	) {
		super(message);
		this.name = "BudgetPausedError";
	}
}

/**
 * Confidence gap calculation error (422)
 *
 * Thrown when confidence or steering calculations fail unexpectedly.
 * This is a programming error - the system should always be able to
 * calculate confidence from available data.
 */
export class ConfidenceGapError extends Error {
	readonly _tag = "ConfidenceGapError";

	constructor(
		public readonly sessionId: string,
		public readonly message: string,
		public readonly cause?: string,
	) {
		super(message);
		this.name = "ConfidenceGapError";
	}
}

/**
 * @deprecated Use ConfidenceGapError instead
 */
export const PrecisionGapError = ConfidenceGapError;
